---

# Краткий гайд по написанию агента в рамках example lab

Гайд будет дополнен и значительно изменён в пятницу-субботу. Это пока что достаточно сырой вариантик. Ждите субботы короче

---

## Содержание
- [Источники и документация](#sources)
- [Предисловие](#preface)
    - [Всё есть граф](#all_is_graph)
    - [Хранение SC объектов](#sc-objects)
    - [Один и тот же узел](#same_node)
- [Получение входных данных агентом](#input)
- [Реализация алгоритма](#algorithm)
    - [Итераторы3 и Итераторы5](#iterators)
        - [Итераторы3](#iterator3)
        - [Итераторы5](#iterator5)
- [Формирование выходных данных и вывод результата](#output)
- [Основные проблемы](#main_problems)
    - [Проблема неориенированных дуг](#noorient_problem)
    - [Проблема случайных результатов поиска](#random_neghbours)

---

## <a id="sources">Источники и документация</a>

- Вот [это](https://github.com/ostis-ai/ostis-web-platform/blob/develop/docs/main.pdf) просто почитать по желанию.
- А вот [это](http://ostis-dev.github.io/sc-machine/) более ли менее вменяемая документация.

---

## <a id="preface">Небольшое предисловие</a>

Cвязанные проблемы желательно читать после прочтения основного содержания гайда

---

### <a id="all_is_graph">Всё есть граф</a>

Весь интерфейс веб-платформы фактически состоит из узлов графа нашей базы знаний и кода который их обрабатывает. Поэтому часто принципы работы придется описывать в виде графа.

---

### <a id="sc-objects">Хранение SC объектов</a>

Sc-обьектами считаются узлы(вершины) и дуги(ребра) графа. 

Узлы хранят информацию о их системном идентификаторе(в каком-то смысле название переменной), о связях(дугах), в которых они являются родительским узлом(от которого проведена дуга), о связях, в которых они являюся наследником(к которому проведена дуга).

Дуги хранят информацию об их системном идентификаторе(если таковой есть), об узле-родителе данной связи, об узле-наследнике(корректней будет сказать об обьекте-наследнике, т.к. связь может быть проведена и к другой дуге) данной связи и о связях проведённых к текущей.

Доступ к любому Sc-обьекту можно получить с помощью его ScAddr(адреса) он хранит hash-идентификатор данного обьекта и с его помощью находит его в памяти.

[Связанная проблема](#noorient_problem) 

---

### <a id="same_node">Один и тот же узел</a>

При сборке базы знаний все узлы собираются в один большой граф по системным идентификаторам, поэтому узлы в исходных файлах с одинаковыми системными идентификаторами будут в памяти являться одной и той же вершиной, и все связи проведенные от/к этому узлу будут храниться у одной и той же вершины. Например в первом нашем графе была следующая кострукция: concept_cat <- animal_set; а во втором графе concept_cat <- pets_set; и если мы обратимся к этому узлу, мы получим обе связи. Это просто нужно держать в голове.

[Связанная проблема](#random_neghbours) 

---

## Основные пункты при создании агента:

1. [Получение входных данных агентом](#)
2. [Реализация алгоритма](#)
3. [Формирование выходных данных и вывод результата](#)

---

## <a id="input">Получение входных данных агентом</a>

Начнем с передачи обекта(ов) в агента. Как я упоминал ранее, весь интерфейс веба является некоторым графом. Когда мы нажимаем пкм по узлу и нажимаем "закрепить"(булавка) мы создаем ребро от узла, который участвует в работе агента, под названием otherAddr к выбранному обьекту. Чтобы после этого вызвать нашего агента, мы нажимаем на кнопку нашего агента, после чего проверяется достаточно ли у otherAddr исходящих рёбер. Если их достаточно, проводится ребро от listenAddr нашего агента к otherAddr. При регистрации мы писали, что наш агент будет реагировать на событие "Появление ребра". Вот это оно самое. После этого запускается наш агент.


<p align="center">

  <img width="186" height="302" src="https://github.com/Mediano4e/bsuir_guides/assets/115105818/129660f6-3767-4fe5-899f-c976b1100541">

</p>

Теперь нам нужно получить переданные узлы в самом агенте. Для этого нам надо обратиться непосредственно к otherAddr.

```c++
ScAddr actionNode = otherAddr; 
```
Если у нас передан один аргумент, то можем его получить через команду(фактически, забегая наперёд, getAnyFromSet использует простейший итератор-тройку):
```c++
ScAddr myInputObject = IteratorUtils::getAnyFromSet(ms_context.get(), actionNode); 
```

Если же у нас больше одного аргумента, то используем для этого цикл и вектор аргументов:
```c++
ScAddrVector myInputObjects;
int i = 0, n = 2;

while (i < n)
{
    myInputObjects.insert( myInputObjects.end(), IteratorUtils::getAnyFromSet(ms_context.get(), actionNode) );
    i++;
}
```
где n -- число ваших аргументов.

## <a id="algorithm">Реализация алгоритма</a>

Если вы будете писать в обычных редакторах кода типо VS или обычного блокнота, то для отладки советую использовать для вывода в консоль:
```c++
SC_LOG_ERROR("something to show in console");
```

Если хотите получить системный идентификатор строкой, то можно использовать(в данном случае название выведется в консоль):

```c++
SC_LOG_ERROR( m_memoryCtx.HelperGetSystemIdtf(yourVertex) );
```

Если же у вас Clion, то там уже куда более интересная история... [Смотреть в источнике...](https://youtu.be/dQw4w9WgXcQ?si=hc3lnLTvzrwybdav)

---

__Главным инструментом для реализации алгоритма являются Итераторы__

---

### <a id="iterators">Итераторы3 и Итераторы5</a>

<p align="left">

  <img width="411" height="135" src="https://ostis-dev.github.io/sc-machine/cpp/images/iterators_scheme.png">

</p>

Итераторы являются универсальным инструментом для перехода от вершины к вершине и для прочих манипуляций с графовыми структурами. Итераторы соответствуют маленьким шаблонам(см Лаб 4 по МОИСу) на 2 вершины и одну связь без узла отношений, либо с ним и соответствущим ему ребром.

---

#### <a id="iterator3">__Итератор3__</a>

Чтобы наш шаблон заработал, нам нужно хотя бы один объект задать явно.

То есть вот синтаксис:

```c++
ScAddr actioNode = otherAddr;
ScAddr myInputNode = IteratorUtils::getAnyFromSet(ms_context.get(), actionNode); 

ScIterator3Ptr it3 = m_memoryCtx.Iterator3(
            myInputObject,            // ->Get(0)
            ScType::Unknown,          // ->Get(1)
            ScType::Unknown);         // ->Get(2)

while (it3->Next())
{
    SC_LOG_ERROR( m_memoryCtx.HelperGetSystemIdtf( it3->Get(2) ) );
}
```
В примере выше мы вернём все связи, в которых myInputNode является РОДИТЕЛЬСКИМ узлом, и соответствующие им объекты(это могут быть и узлы и связи). Через цикл while будут перебираться результаты поиска. Можно поставить myInputNode на позицию узла НАСЛЕДНИКА(позиция 2), и тогда результаты будут другими. Направление рёбер(стрелок) от узла родителя к узлу наследнику.

Каждому неизвестному можно задать тип(задать объект неявно), чтобы получить именно то, что нам нужно. Вот пример, который пройдется по всем конструкциям включающим myInputNode родительским узлом, некоторую связь и некоторый константный узел:  

```c++
ScAddr actioNode = otherAddr;
ScAddr myInputObject = IteratorUtils::getAnyFromSet(ms_context.get(), actionNode); 

ScIterator3Ptr it3 = m_memoryCtx.Iterator3(
            actionNode,               // ->Get(0)
            ScType::Unknown,          // ->Get(1)
            ScType::NodeConst);       // ->Get(2)
    
while (it3->Next())
{
    SC_LOG_ERROR( m_memoryCtx.HelperGetSystemIdtf( it3->Get(2) ) );
}
```

---

#### <a id="iterator5">__Итератор5__</a>

По своей сути Итератор5 отличается от Итератора3 только тем, что ищет конструкции, у которых есть узел отношений(впринципе это может быть любой узел соответствующий данному шаблону).

Пример синтаксиса:
```c++
ScAddr actionNode = otherAddr;
ScAddr myInputNode = IteratorUtils::getAnyFromSet(ms_context.get(), actionNode); 

ScIterator5Ptr it5 = m_memoryCtx.Iterator5(
        myInputNode,                        // ->Get(0)
        ScType::Unknown,                    // ->Get(1)
        ScType::NodeConst,                  // ->Get(2)
        ScType::EdgeAccessConstPosPerm,     // ->Get(3)
        ScType::NodeConst);                 // ->Get(4)

while (it5->Next())
{
    SC_LOG_ERROR( m_memoryCtx.HelperGetSystemIdtf( it5->Get(2) ) );
    SC_LOG_ERROR( m_memoryCtx.HelperGetSystemIdtf( it5->Get(4) ) );
}
```

Т.к. это работает так же как и шаблоны, Итератор3 найдет конструкции и на пять элементов, но полностью проигнорирует наличие аргументов 3 и 4. А вот Итератор5 конструкции без узла отношений обходить не будет.

---

Все типы объектов можно найти [тут](https://github.com/Mediano4e/bsuir_guides/blob/in_dev/example_app_agent/useful_sources/sc_type.cpp).

---

## <a id="output">Формирование выходных данных и вывод результата</a>

Если наш агент столкнулся с ошибкой или по какой-либо причине не смог правильно отработать, то нам нужно завершить его с флагом false и передать ему узел с вводными данными, чтобы он отчистил его:

```c++
ScAddr actionNode = otherAddr;
utils::AgentUtils::finishAgentWork(&m_memoryCtx, actionNode, false);
```

Если наш агентом всё успешно выполнил, то мы завершаем его с флагом true и передаём ему помимо узла с аргументами вектор всех Sc-объектов, которые мы хотим вывести помимо самих аргументов в качестве результата:

```c++
ScAddr actionNode = otherAddr;
ScAddrVector answerElements;
utils::AgentUtils::finishAgentWork(&m_memoryCtx, actionNode, answerElements, true);
```

---

Чтобы создать непосредственно объекты, которые попадут в вектор выходных можно использовать:

```c++
ScAddrVector answerElements;

//создание пустого узла определённого типа 
ScAddr nodeForAnswer = m_memoryCtx.CreateNode(ScType::NodeConst);  

//создание дуги опредённого типа от родительского узла к узлу наследнику
ScAddr edgeForAnswer1 = m_memoryCtx.CreateEdge(ScType::EdgeDCommonConst, myParentNode, myChildNode); 

//создание дуги опредённого типа от родительского узла к другому ребру
ScAddr edgeForAnswer2 = m_memoryCtx.CreateEdge(ScType::EdgeAccessConstPosPerm, nodeForAnswer, edgeForAnswer1); 

//И добавляем всё, что мы использовали, но что не является одним из изначальных аргументов, в вектор ответов
answerElements.insert(answerElements.end(), {nodeForAnswer, myParentNode, myChildNode, edgeForAnswer1, edgeForAnswer2});
```

Если же вам нужны узлы с определёнными идентификаторами, задекларируйте их в Keynodes, их можно будет использовать в агенте в виде Keynodes::my_node, его тоже нужно будет добавлять в вектор ответов.

Если вам нужно удалить какой-либо объект, то это можно сделать так:

```c++
m_memoryCtx.EraseElement(objectForDelete);
```

---

## <a id="main_problems">Основные проблемы при реализации агента</a>

Здесь описанны основные неприятные моменты при написании агентов. 

---

### <a id="noorient_problem">Проблема неориентированных дуг</a>

У любых дуг есть родительский узел и узел наследник, и пока мы используем ориентированные дуги проблем не возникает.  
Однако также существуект в SС одна неориентированная дуга, но она тоже попадает под эту концепцию.

Если мы хотим получить все узлы, с которыми у данного узла неориентированная связь, придётся использовать два итератора(один с искомым узлом на позиции родителя и второй -- на позиции наследника):

```c++
ScAddrVector neghbourNodes;

ScIterator3Ptr it3_1 = m_memoryCtx.Iterator3(
            myNode,              
            ScType::EdgeUCommonConst,          
            ScType::NodeConst);      
    
while (it3_1->Next())
{
    neghbourNodes.insert(neghbourNodes.end(), it3_1->Get(2))
}

ScIterator3Ptr it3_2 = m_memoryCtx.Iterator3(
            ScType::NodeConst,              
            ScType::EdgeUCommonConst,          
            myNode);      
    
while (it3_2->Next())
{
    neghbourNodes.insert(neghbourNodes.end(), it3_2->Get(0))
}
```
[К предисловию](#sc-objects)

---

### <a id="random_neghbours">Проблема случайных результатов поиска</a>

Учитывая, что у нас все узлы с одинаковыми системными идентификаторами объединяются в один узел, у наших узлов могут возникнуть куча непонятных связей, которые нам нужно как-то обрабатывать.

Поэтому, если вы в качестве аргумента передаете системный идентификатор контура, то можно прибегнуть к следующим шагам:

1. Сохранить адреса всех вершин нашего графа с помощью итератора3 в вектор, и перейдя на другой узел проверять, пренадлежит ли он нашему вектору;
2. При обходе графа использовать итераторы5(пусть inputStruct - название нашего контура):

```c++
ScAddr actionNode = otherAddr;
ScAddr inputStruct = IteratorUtils::getAnyFromSet(ms_context.get(), actionNode); 

ScIterator5Ptr it5 = m_memoryCtx.Iterator5(
        myCurrentNode,                        
        ScType::Unknown,                    
        ScType::NodeConst,                  
        ScType::EdgeAccessConstPosPerm,     
        inputStruct);                 

while (it5->Next())
{
   ...
}
```
[К предисловию](#same_node)

[Примеры выполнения агентов](https://github.com/Mediano4e/bsuir_guides/tree/main/example_app_agent/examples)
