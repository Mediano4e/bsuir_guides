# Краткий гайд по написанию агента в рамках example lab

## Источники и документация

- Вот [это](https://github.com/ostis-ai/ostis-web-platform/blob/develop/docs/main.pdf) просто почитать по желанию.
- А вот [это](http://ostis-dev.github.io/sc-machine/) более ли менее вменяемая документация.

## Небольшое предисловие

Cвязанные проблемы желательно читать после прочтения основного содержания гайда

### Всё есть граф

Весь интерфейс веб-платформы фактически состоит из узлов графа нашей базы знаний и кода который их обрабатывает. Поэтому часто принципы работы придется описывать в виде графа.

### Хранение SC объектов

Sc-обьектами считаются узлы(вершины) и дуги(ребра) графа. 

Узлы хранят информацию о их системном идентификаторе(в каком-то смысле название переменной), о связях(дугах), в которых они являются родительским узлом(от которого проведена дуга), о связях, в которых они являюся наследником(к которому проведена дуга).

Дуги хранят информацию об их системном идентификаторе(если таковой есть), об узле-родителе данной связи, об узле-наследнике(корректней будет сказать об обьекте-наследнике, т.к. связь может быть проведена и к другой дуге) данной связи и о связях проведённых к текущей.

Доступ к любому Sc-обьекту можно получить с помощью его ScAddr(адреса) он хранит hash-идентификатор данного обьекта и с его помощью находит его в памяти.

[Связанная проблема](#) 

### Один и тот же узел

При сборке базы знаний все узлы собираются в один большой граф по системным идентификаторам, поэтому узлы в исходных файлах с одинаковыми системными идентификаторами будут в памяти являться одной и той же вершиной, и все связи проведенные от/к этому узлу будут храниться у одной и той же вершины. Например в первом нашем графе была следующая кострукция: concept_cat <- animal_set; а во втором графе concept_cat <- pets_set; и если мы обратимся к этому узлу, мы получим обе связи. Это просто нужно держать в голове.

[Связанная проблема](#) 

## Основные пункты при создании агента:

1. [Получение входных данных агентом](#)
2. [Реализация алгоритма](#)
3. [Формирование выходных данных и вывод результата](#)

## Получение входных данных агентом

Начнем с передачи обекта(ов) в агента. Как я упоминал ранее, весь интерфейс веба является некоторым графом. Когда мы нажимаем пкм по узлу и нажимаем "закрепить"(булавка) мы создаем ребро от узла, который участвует в работе агента, под названием otherNode к выбранному обьекту. Чтобы после этого вызвать нашего агента, мы нажимаем на кнопку нашего агента, после чего проверяется достаточно ли у otherNode исходящих рёбер. Если их достаточно, проводится ребро от listeningNode нашего агента к otherNode. При регистрации мы писали, что наш агент будет реагировать на событие "Появление ребра". Вот это оно самое. После этого запускается наш агент.

Теперь нам нужно получить переданные узлы в самом агенте. Для этого нам надо обратиться непосредственно к otherNode.

```c++
ScAddr actionNode = otherNode; 
```
Если у нас передан один аргумент, то можем его получить через команду(фактически, забегая наперёд, getAnyFromSet использует простейший итератор-тройку):
```c++
ScAddr myInputObject = IteratorUtils::getAnyFromSet(ms_context.get(), actionNode); 
```

Если же у нас больше одного аргумента, то используем для этого цикл и вектор аргументов:
```c++
ScAddrVector myInputObjects;
int i = 0, n = 2;
while (i < n)
{
    myInputObjects.insert(myInputObjects.end(), IteratorUtils::getAnyFromSet(ms_context.get(), actionNode));
    i++;
}
```
где n -- число ваших аргументов.

## Реализация алгоритма

Если вы будете писать в обычных редакторах кода типо VS или обычного блокнота, то для отладки советую использовать для вывода в консоль:
```c++
SC_LOG_ERROR("something to show in console");
```

Если хотите получить системный идентификатор строкой, то можно использовать(в данном случае название выведется в консоль):

```c++
SC_LOG_ERROR( m_memoryCtx.HelperGetSystemIdtf(yourVertex) );
```

Если же у вас Clion, то там уже куда более интересная история... [Смотреть в источнике...](#)

Главным инструментом для реализации алгоритма являются Итераторы

### Итераторы3 и Итераторы5

Итераторы являются универсальным инструментом для перехода от вершины к вершине и для прочих манипуляций с графовыми структурами. Итераторы соответствуют маленьким шаблонам(см Лаб 4 по МОИСу) на 2 вершины и одну связь без узла отношений, либо с ним и соответствущим ему ребром.

#### Итератор3

Чтобы наш шаблон заработал, нам нужно хотя бы один объект задать явно.

То есть вот синтаксис:

```c++
ScAddr actioNode = otherNode;
ScAddr myInputNode = IteratorUtils::getAnyFromSet(ms_context.get(), actionNode); 

ScIterator3Ptr it3 = m_memoryCtx.Iterator3(
            myInputObject,               // ->Get(0)
            ScType::Unknown,          // ->Get(1)
            ScType::Unknown);         // ->Get(2)

while (it3->Next())
{
    SC_LOG_ERROR( m_memoryCtx.HelperGetSystemIdtf( it3->Get(2) ) );
}
```
В примере выше мы вернём все связи, в которых myInputNode является РОДИТЕЛЬСКИМ узлом, и соответствующие им объекты(это могут быть и узлы и связи). Через цикл while будут перебираться результаты поиска. Можно поставить myInputNode на позицию узла НАСЛЕДНИКА(позиция 2), и тогда результаты будут другими. Направление рёбер(стрелок) от узла родителя к узлу наследнику.

Каждому неизвестному можно задать тип(задать объект неявно), чтобы получить именно то, что нам нужно. Вот пример, который пройдется по всем конструкциям включающим myInputNode родительским узлом, некоторую связь и некоторый константный узел:  

```c++
ScAddr actioNode = otherNode;
ScAddr myInputObject = IteratorUtils::getAnyFromSet(ms_context.get(), actionNode); 

ScIterator3Ptr it3 = m_memoryCtx.Iterator3(
            actionNode,               // ->Get(0)
            ScType::Unknown,          // ->Get(1)
            ScType::NodeConst);       // ->Get(2)
    
while (it3->Next())
{
    SC_LOG_ERROR( m_memoryCtx.HelperGetSystemIdtf( it3->Get(2) ) );
}
```

#### Итератор5

По своей сути Итератор5 отличается от Итератора3 только тем, что ищет конструкции, у которых есть узел отношений(впринципе это может быть любой узел соответствующий данному шаблону).

Пример синтаксиса:
```c++
ScAddr actionNode = otherNode;
ScAddr myInputNode = IteratorUtils::getAnyFromSet(ms_context.get(), actionNode); 

ScIterator5Ptr it5 = m_memoryCtx.Iterator5(
        myInputNode,                        // ->Get(0)
        ScType::Unknown,                    // ->Get(1)
        ScType::NodeConst,                  // ->Get(2)
        ScType::EdgeAccessConstPosPerm,     // ->Get(3)
        ScType::NodeConst);                 // ->Get(4)

while (it5->Next())
{
    SC_LOG_ERROR( m_memoryCtx.HelperGetSystemIdtf( it5->Get(2) ) );
    SC_LOG_ERROR( m_memoryCtx.HelperGetSystemIdtf( it5->Get(4) ) );
}
```

Т.к. это работает так же как и шаблоны, Итератор3 найдет конструкции и на пять элементов, но полностью проигнорирует наличие аргументов 3 и 4. А вот Итератор5 конструкции без узла отношений обходить не будет.

Все типы объектов можно найти [тут]().

## Формирование выходных данных и вывод результата



## Основные проблемы при реализации агента



### Проблема неориентированных дуг



### Проблема случайных результатов поиска

